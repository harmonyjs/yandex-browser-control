<!-- Generated by https://github.com/harmonyjs/instructions -->

Here are some instructions that you should follow when generating code. Please follow these rules carefully and do not deviate from them. If you have any questions or are unable to comply with any of these instructions, please explain the reason to the user.

```yaml
ruleset:
  version: "2025-08-24"
  priority: critical

  # Here MUST/SHOULD/MAY semantics is used
  # @see https://www.rfc-editor.org/rfc/rfc2119
  semantics: "RFC-2119"

  conflict_resolution: >
    When rules conflict, groups listed first take precedence; within a group, MUST overrides SHOULD and MAY.

  groups:

    - title: Execution & Mindset
      rules:

        # Rationale: Focus keeps the codebase lean, reviewable, and maintainable.
        # Tags: yagni, minimalism, scope-control
        - title: Minimal, Purpose-Driven Implementation
          must:
            - Implement only what is strictly required to satisfy the task—no feature creep or speculative abstractions.

        # Rationale: Ensures structured reasoning, surfaces ambiguities, improves accuracy and repeatability.
        # Tags: thinking-tool, reasoning, analysis, copilot
        - title: Thinking Tool
          must:
            - Invoke the Thinking Tool on every new user request to analyze the task and draft a solution.

        # Rationale: Automatic resolution of routine errors accelerates development and reduces overhead.
        # Tags: autonomy, lint, typecheck, tests, maintenance
        - title: Autonomous Error Corrections
          must:
            - When lint, typecheck, or test errors are detected, immediately fix the underlying issues without asking permission.
          should:
            - Consult the user only for strategic or architectural decisions, not routine maintenance.

    - title: Code Design & Structure
      rules:

        # Rationale: Readable, documented code accelerates onboarding and refactors.
        # Tags: style, comments, pure-functions, documentation
        - title: Idiomatic, Well-Commented Code
          must:
            - Write clear TypeScript/JavaScript matching the existing style for indentation, quotes, and imports.
            - Favor pure functions; when side effects are unavoidable, document them explicitly.
          should:
            - Add JSDoc and, where it truly helps, small ASCII-art diagrams; avoid noisy diagrams that bloat diffs.

        # Rationale: Improves readability, testability, and maintainability.
        # Tags: srp, modularity, responsibility
        - title: Single Responsibility Principle
          must:
            - Ensure every function or module has one clear responsibility.
            - Split overly complex functions into smaller, focused units.

        # Rationale: Smaller units are easier to test, reason about, and reuse.
        # Tags: modularity, refactor, file-size
        - title: Modular Design & File Size Limits
          must:
            - Decompose logic into small self-contained modules/functions.
            - Keep each source file <= 200 lines; refactor or split when approaching the limit.

        # Rationale: Prevents needless complexity and keeps APIs straightforward.
        # Tags: abstraction, oop, modules
        - title: Avoid Hollow Static-Only Classes & Over-Abstraction
          must:
            - Do not wrap unrelated helpers in static-method classes; use plain modules or namespaces.
          should:
            - Introduce abstraction layers only when demonstrably necessary.

        # Rationale: Enforceable visibility yields clearer APIs and safer refactoring.
        # Tags: encapsulation, access-control, typescript, javascript
        - title: Use Proper Encapsulation, Not Underscore Prefixes
          must:
            - Do not use leading underscores (e.g., _foo) to signal privacy.
            - Enforce visibility via language constructs (private/protected, \#private fields), module scope, closures, or explicit access modifiers.
            - Separate public and private surfaces via exports or interface definitions.

        # Rationale: Controlled reuse reduces bugs without adding unnecessary layers.
        # Tags: dry, reusability, utilities
        - title: Extract Reusable Utilities
          should:
            - Identify repeated patterns and extract shared helpers/modules only when duplication recurs ≥2–3 times.

        # Rationale: Prevents bloated signatures, reduces cognitive load, improves decoupling.
        # Tags: functions, design, api, clean-code
        - title: Avoid Parameter Drilling
          must:
            - Functions declare and accept only the parameters they actually use.
            - Do not forward unused parameters through intermediate calls.
          should:
            - Share cross-cutting data via a typed context or dependency injection instead of drilling.

    - title: Modules & Imports
      rules:

        # Rationale: Deterministic imports improve readability, bundling, and tooling.
        # Tags: imports, node, static, aliasing
        - title: Strict Import Conventions
          must:
            - Import Node built-in modules with the "node:" protocol.
            - Use "#" subpath aliases WHEN package.json#imports/TS/bundler are configured; otherwise use project-approved aliases or relative paths.
            - Prefer static imports; MAY use dynamic import() for lazy-loading/code-splitting with a short rationale comment.

        # Rationale: Eliminates dead code, avoids unnecessary dependencies, keeps the codebase clean.
        # Tags: imports, cleanup, lint
        - title: Remove Unused Variables and Imports
          must:
            - Remove any variable or module that is never used (and not imported for side effects) rather than muting via underscores or pragmas.

    - title: JavaScript/TypeScript Idioms
      rules:

        # Rationale: Promotes predictable behavior, performance, and maintainability.
        # Tags: javascript, async, errors, functional
        - title: Modern JavaScript Patterns
          must:
            - Prefer for…of loops or Array.map over forEach for iteration.
            - Avoid "return await"; USE it inside try/catch/finally when correct error/stack semantics are required.
            - Prefer typed errors and rethrow; log at process/service/module boundaries to avoid duplicate logs.
            - Minimize mutation; use a functional style.
          should:
            - Use Object.freeze/Object.seal only when justified, documenting each use.
            - Avoid argument forwarding anti-patterns.

        # Rationale: Transparency around side effects simplifies debugging and parallelization.
        # Tags: purity, side-effects, documentation
        - title: Pure Functions & Documented Side-Effects
          must:
            - Prefer pure functions by default.
            - When I/O or external mutation is necessary, document what is modified, why it’s required, and safeguards applied.

    - title: Testing
      rules:

        # Rationale: Nearby tests improve discoverability and encourage maintenance.
        # Tags: testing, unit-tests, structure
        - title: Co-Locate Unit Tests
          must:
            - Place unit tests next to the code they verify rather than in __tests__ directories.
            - Extend coverage to edge cases introduced by your change.

    - title: Documentation
      rules:

        # Rationale: Preserves clarity, prevents misuse, and ensures accountability in reviews.
        # Tags: lint, comments, eslint, typescript
        - title: Document Disable Directives
          must:
            - Precede any disable directive (e.g., // eslint-disable-next-line, // eslint-disable, // @ts-ignore) with a comment explaining why it is necessary and what issue it addresses.

        # Rationale: Keeps documentation in lockstep with code, preserving architectural clarity.
        # Tags: documentation, docs, consistency, architecture, maintainability
        - title: Sync Documentation with Code Changes
          should:
            - For every edited code file, update the most relevant nearest README.md when behavior or architecture changes; avoid creating duplicates—maintain the single closest, most pertinent README.
            - Verify all modified READMEs remain accurate and consistent.

    - title: Project Layout & Naming
      rules:

        # Rationale: Consistent naming improves discoverability.
        # Tags: filesystem, naming, structure
        - title: Kebab-Case Project Layout
          must:
            - Use kebab-case for all directory and file names.
          should:
            - Keep layout pragmatic; avoid heavy DDD if it hurts clarity.

        # Rationale: Shortens paths, enhances discoverability, avoids repetition.
        # Tags: filesystem, naming, structure
        - title: Avoid Redundant Directory Name Prefixes
          must:
            - Do not repeat the parent directory name as a file prefix (e.g., utils/utils-helpers.ts → utils/helpers.ts).
          should:
            - Use `index.ts` for module entry points instead of duplicating directory names.
```